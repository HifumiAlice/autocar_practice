#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import cv2
import numpy as np

# Publish
#   Topic Name --> /high_level/ackerman_cmd_mux/input/nav_0
#   MSG Tyle --> ackermann_msgs/AckermannDriveStamped
#   Steering angle : -0.34 ~ 0.34
#   speed : -10m/s ~ 10m/s   (권장 : -2.5 ~ 2.5)

from ackermann_msgs.msg import AckermannDriveStamped
from km_race.msg import dist, filteredlidar
from std_msgs.msg import String

class Controller():
    def __init__(self) :
        self.dist_right = 0
        self.dist_left = 0

        self.dist_x_left = 0
        self.dist_y_left = 0
        self.dist_x_right = 0
        self.dist_y_right = 0

        self.CVT_x_left = 0
        self.CVT_y_left = 0
        self.CVT_x_right = 0
        self.CVT_y_right = 0

        self.ROI_x_left = 0
        self.ROI_y_left = 0
        self.ROI_x_right = 0
        self.ROI_y_right = 0
        
        # total dist = 315 for widht of lane = 350
        # self.ref_dist_right = 185           # crop image size가 320일때
        self.ref_dist_right = 165           # crop image size가 300일때
        self.ref_dist_left = 130         # <==== 차선의 중심에 놓고 거리를 확인하여 변경해야 한다.

        self.data_source = "CVT"        # DEFAULT SOURCE = CVT, (CVT, ROI)
        self.select_LR = "R"            # R, L

        self.dist_x_minlimit = 30
        self.dist_x_maxlimit = 290

        self.warning = False
        self.ROI_process = True
        self.CVT_process = True

        # Driving Mode
        self.Lane_Driving = True        # True = Lane Driving, False : No Lane Driving
        self.Driving_speed = 1          # -1 = Slow, 0 = Normal, 1 = Fast

        # Driving Parameter
        self.speed_limit = 1
        self.speed_min = 0.3
        self.speed_normal = 0.5

        # Obstacle Moving Status
        self.obs_moving = False         # 물체가 움직일 경우 True - lidar_clustered_Callback :  에서 처리됨

        self.init_param(speed=self.speed_normal)

        self.cvtsubscriber = rospy.Subscriber("cvtdist", dist, self.cvtlane_callback )
        self.roisubscriber = rospy.Subscriber("roidist", dist, self.roilane_callback )
        # self.subscriber = rospy.Subscriber("lidar_warning_pub", String, self.warning_callback )
        self.lidarsubscriber = rospy.Subscriber("lidar_clustering", filteredlidar, self.lidar_clustered_Callback )

        self.drive_pub = rospy.Publisher("high_level/ackermann_cmd_mux/input/nav_0", AckermannDriveStamped, queue_size = 1)

        rospy.Timer(rospy.Duration(1.0/30), self.timer_callback )

    def timer_callback(self, _event) :
        rospy.loginfo("[Timer CB] - {}({}) - left=({},{}), right=({},{}, warning({}))".format(self.data_source, self.select_LR, 
                        self.dist_x_left, self.dist_y_left, self.dist_x_right, self.dist_y_right, self.warning))

        if self.Lane_Driving :
            pass
        else :
            if (self.dist_x_right == 0) and (self.dist_x_left == 0):
                self.stop()
                rospy.loginfo("Lane is not detected.")
            # elif self.warning :
            #     self.stop()
            #     rospy.loginfo("Object is detected by LiDAR.")
            else :
                self.follow_lane(  )

    def follow_lane(self) :
        self.error_right = self.ref_dist_right - self.dist_x_right    
        self.error_left = self.ref_dist_left - self.dist_x_left           

        # rospy.loginfo("Error Right={}, right={}".format(self.error_right, self.dist_right))
        # rospy.loginfo("Error Left={}, left={}".format(self.error_left, self.dist_left))

        # 음수 -> 오른쪽 차선에서 멀다 -> 오른쪽으로 붙여야 한다. -> 바퀴를 오른쪽으로 회전 -> steering_angle을 음수
        # 양수 -> 오른쪽 차선에서 가깝다 -> 왼쪽으로 붙여야 한다. -> 바퀴를 왼쪽으로 회전 -> steering_angle을 양수

        publishing_data = AckermannDriveStamped()
        publishing_data.header.stamp = rospy.Time.now()
        publishing_data.header.frame_id = "base_link"

        if (self.select_LR == "R") :
            publishing_data.drive.steering_angle = self.error_right * (self.steering_rate / self.speed)
            # rospy.loginfo("Right lane check -----")
        else :
            publishing_data.drive.steering_angle = self.error_left * (self.steering_rate / self.speed)
            # rospy.loginfo("Left lane check -----")

        publishing_data.drive.speed = self.speed
        self.drive_pub.publish(publishing_data)
        # rospy.loginfo("Publish control data")

    # 차선 변경
    # _direction : 방향
    def changeLane(self, _direction) :
        if _direction == 'L' : 
            if self.select_LR == 'L' :
                self.error_left = self.ref_dist_left - self.dist_x_left + 320
                publishing_data = AckermannDriveStamped()
                publishing_data.header.stamp = rospy.Time.now()
                publishing_data.header.frame_id = "base_link"
                publishing_data.drive.steering_angle = self.error_left * (self.steering_rate / self.speed)
                publishing_data.drive.speed = self.speed
                self.drive_pub.publish(publishing_data)
            if self.select_LR == 'R' :
                self.error_right = self.ref_dist_right - self.dist_x_left -320  
                publishing_data = AckermannDriveStamped()
                publishing_data.header.stamp = rospy.Time.now()
                publishing_data.header.frame_id = "base_link"
                publishing_data.drive.steering_angle = self.error_left * (self.steering_rate / self.speed)
                publishing_data.drive.speed = self.speed
                self.drive_pub.publish(publishing_data)

        if _direction == 'R' :
            pass
        
    def lidar_clustered_Callback(self, _data) :
        rospy.loginfo("[Controller][lidar_clustered]={}".format(_data))

        if (_data.no_obstacle == 1) :
            self.obs_moving = self.check_moving_obs()
        elif _data.no_obstacle > 1 :
            self.Lane_Driving = False
            self.obstacle_data = _data

    def check_moving_obs(self, _data) :
        return False

    def noLaneDriving(self) :
        pass


    def setSpeed(self, _target) :
        pass

    def slowDriving(self, _event) :
        pass

    def setDistData(self) :
        if (self.data_source == "CVT") :
            self.dist_x_left =  self.CVT_x_left
            self.dist_y_left = self.CVT_y_left
            self.dist_x_right = self.CVT_x_right
            self.dist_y_right = self.CVT_y_right
            if self.CVT_x_right != 0 :
                self.select_LR = 'R'
            elif (self.CVT_x_left != 0) :
                self.select_LR = 'L'
            else :
                self.CVT_process = False

        elif (self.data_source == "ROI") :
            self.dist_x_left =  self.ROI_x_left
            self.dist_y_left = self.ROI_y_left
            self.dist_x_right = self.ROI_x_right
            self.dist_y_right = self.ROI_y_right
            if self.ROI_x_right != 0 :
                self.select_LR = 'R'
            elif (self.ROI_x_left != 0) :
                self.select_LR = 'L'
            else :
                self.ROI_process = False
            
    def getCVTData(self, _data) :
        self.CVT_x_left = _data.dist_x_left
        self.CVT_y_left = _data.dist_y_left

        self.CVT_x_right = _data.dist_x_right
        self.CVT_y_right = _data.dist_y_right
        self.setDistData()


    def getROIData(self, _data) :
        self.ROI_x_left = _data.dist_x_left
        self.ROI_y_left = _data.dist_y_left

        self.ROI_x_right = _data.dist_x_right
        self.ROI_y_right = _data.dist_y_right
        self.setDistData()

    def cvtlane_callback(self, _data) :
        if (self.data_source == "CVT") :
            self.getCVTData(_data)

            # self.checkProcess()
            # rospy.loginfo("[CVT CB] Source ({}) CVT({}) - left=({},{}), right=({},{})".format(self.data_source, self.select_LR, \
            #     self.dist_x_left, self.dist_y_left, self.dist_x_right, self.dist_y_right))

    def roilane_callback(self, _data) :
        if self.data_source == "ROI" :
            self.getROIData(_data)
            # rospy.loginfo("[ROI CB]Source ({}) ROI({}) - left=({},{}), right=({},{})".format(self.data_source, self.select_LR, \
            #     self.dist_x_left, self.dist_y_left, self.dist_x_right, self.dist_y_right))
        
        # self.checkProcess()

    def checkCVTROI(self) :
        pass

    # def checkProcess(self) :
    #     if self.dist_x_right == 0 and self.dist_x_left == 0 :
    #         if ( self.data_source == 'CVT' ) :
    #             if self.ROI_process == True  :
    #                 self.CVT_process = False
    #                 self.data_source = 'ROI'
    #             else :
    #                 self.stop()
    #                 rospy.loginfo("CVT and ROI can not detect the lane.(1)")
    #         else :
    #             if self.CVT_process == True :
    #                 self.data_source = 'CVT'
    #                 self.ROI_process = False
    #             else :
    #                 self.stop()
    #                 rospy.loginfo("CVT and ROI can not detect the lane.(2)")
    #     elif self.select_LR == 'L' and self.dist_x_right != 0 and self.dist_x_left == 0 :
    #         self.select_LR = 'R'
    #     elif self.select_LR == 'R' and self.dist_x_left != 0  and self.dist_x_right == 0 :
    #         self.select_LR = 'L'

    def obstacleDrivingCallback(self) :
        pass

    # def warning_callback(self, _data) :
    #     if _data.data == "warning" :
    #         self.warning = True
    #     else :
    #         self.warning = False

    def stop(self) :
        publishing_data = AckermannDriveStamped()
        publishing_data.header.stamp = rospy.Time.now()
        publishing_data.header.frame_id = "base_link"
        publishing_data.drive.steering_angle = 0.0
        publishing_data.drive.speed = 0.0
        self.drive_pub.publish(publishing_data)
        rospy.loginfo("Stop Vehicle!")

    def init_param(self, speed = 0.3, steering_rate = 0.001 ) :
        self.speed = speed
        self.steering_rate = steering_rate

def run():
    rospy.init_node("Controller")
    Controller()
    rospy.spin()

if __name__ == '__main__' :
    run()
